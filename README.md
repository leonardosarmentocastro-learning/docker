### The `docker build` process in detail

- [The Dockerfile](#the-dockerfile)
- [Intermediate containers](#intermediate-containers)
- [Tagging an image](#tagging-an-image)

#### The Dockerfile

To create a Docker image, you need to create a file with a set of instructions. This file is named `Dockerfile`.

Each line of this represents a `step` and Docker will follow them from top to bottom in order to generate your image.

Generally, your set of instructions are organized in the following way:

1. Specify a **base operation system image** to be used;

2. Run commands to install aditional programs;

3. Command to run on container startup;

E.g.

```Dockerfile
# 1. Use an existing docker image as a base
FROM alpine

# 2. Download and install a dependency
RUN apk add --update redis

# 3. Tell the image what to do when its starts as a container
CMD [ "redis-server" ]
```

By running the command `docker build <path to where the Dockerfile is>`, you will be able to see the output of the container creation:

```sh
Step 1/3 : FROM alpine
 ---> 3f53bb00af94
Step 2/3 : RUN apk add --update redis
 ---> Running in 96c6e83ca26e
 ... # log outputs
 Removing intermediate container 96c6e83ca26e
Step 3/3 : CMD [ "redis-server" ]
 ---> Running in 51449f770173
 Removing intermediate container 51449f770173
 Successfully built 961e3e7fa716
```

If you look closer, you can note that after each `step`, the following sentence is shown:

> ---> Running in 96c6e83ca26e

Which leads us to a very interesting topic of why docker is so fast.

#### Intermediate containers

For each `step` specified in our Dockerfile, a snapshot of the filesystem is taken from this step representing the machine's state so far.

If you run `docker build <path to where the Dockerfile is>`, you will face different messages:

```sh
Step 1/3 : FROM alpine
 ---> 3f53bb00af94
Step 2/3 : RUN apk add --update redis
 ---> Using cache
 ---> 96c6e83ca26e
Step 3/3 : CMD [ "redis-server" ]
 ---> Using cache
 ---> 51449f770173
 Successfully built 51449f770173
```

Docker already knows the ways from the step 1 to 2 and 2 from 3. It also noticed that nothing have changed since last time.

Which means he can use the containers created from previous steps to build the image more faster at each interation.

If you add a new instruction between step 2 to 3, everything under it needs to be redone because this is a new graph of possibilities.

Try playing with it yourself, adding this new instruction anywhere you want:

`RUN apk add --update gcc`

#### Tagging an image

To avoid the necessity of running images by the random generated UUID, Docker provides a way to give name to your images, just as the one we have used so far, like `hello-world` or `busybox`.

Do it by executing:

```sh
# Command
docker build desired-name-for-your-image path-to-the-directory-of-your-dockerfile

# The name convention for tag names are:
# your-docker-id/image-name:version
docker build leonardosarmentocastro/my-first-image:latest
```

### Commands

- [docker create](#docker-create)
- [docker start](#docker-start)
- [docker run](#docker-run)
- [docker system prune](#docker-system-prune)
- [docker logs](#docker-logs)
- [docker stop](#docker-stop)
- [docker kill](#docker-kill)
- [docker exec](#docker-exec)
- [docker commit](#docker-commit)

#### `docker create`

Creates a containers, which means, takes a "file system snapshot" of a desired Docker image and allocates it to a namescape inside our hard-drive.

```sh
$ docker create hello-world # "hello-world" is the Docker image name
c041449b290027271787eb3a97f817c2a5af6c2d3efa91c4764775f3e8fec916 # The ID of the container is printed.
```

It is important to notice that "startup command" can only be overriden during this step and can't be done in the future when running the same container.

#### `docker start`

Runs the "startup command" of a given container previously generated by a Docker image.

```sh
$ docker start c041449b290027271787eb3a97f817c2a5af6c2d3efa91c4764775f3e8fec916 # This serial number refers to the previously created container ID.
c041449b290027271787eb3a97f817c2a5af6c2d3efa91c4764775f3e8fec916 # The container ID is printe as well.
```

The container ID is printed instead of the long text message we were used to see. Why?

The `docker start` command, by default, doesn't stick to the container initialization, which means that all signals of "STDOUT/STDERR" from the container are not being listed, therefore, will never be displayed.

To actually see the output we were used to, we need to provide the `--attach, -a` flag.

```sh
$ docker start -a c041449b290027271787eb3a97f817c2a5af6c2d3efa91c4764775f3e8fec916
Hello from Docker! # The message is correctly printed.
This message shows that your installation appears to be working correctly.
...
```

#### `docker run`

Stands for the combination between `docker create` + `docker start`.

```sh
$ docker run <image-name>
$ docker run <image-name> <command> # The "command" argument overrides the "run command" specified by the given docker image

# e.g.
$ docker run ubuntu -it bash
$ docker run ubuntu echo hello, I\'m overriding the startup command for this container
```

You can even start your container and use its shell.

```sh
$ docker run -it busybox sh # could be "zsh", "bash" ...
# ls
# pwd
# ...
```

#### `docker system prune`

Removes all stopped containers, images and build cache (images downloaded from Docker Hub).

```sh
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                           PORTS               NAMES
dfcc9895a74c        hello-world         "echo potato"            33 seconds ago       Created                                              goofy_knuth
fa5fa6c774a9        hello-world         "/hello"                 About a minute ago   Exited (0) 52 seconds ago                            nifty_poitras
c041449b2900        hello-world         "/hello"                 27 minutes ago       Exited (0) 21 minutes ago                            pensive_montalcini

$ docker system prune
WARNING! This will remove:
        - all stopped containers
        - all networks not used by at least one container
        - all dangling images
        - all dangling build cache
Are you sure you want to continue? [y/N] y
Deleted Containers:
dfcc9895a74c4635425a9ead3669402a6e2a5f36806eba984b10279a02d6adf9
fa5fa6c774a92637b641137170b0a80dbeda621574884e28c6c95669ab36f3ec
Total reclaimed space: 35B

$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

#### `docker logs`

Can be used to retrieve results from all "STDOUT/STDERR" emited so far by the container.

```sh
$ docker create busybox echo initializing the container
d9b9cc803a92476d1dbcb8fe2ead52eb541730dce9c6293cef87b015747b91c5

$ docker start d9b9cc803a92476d1dbcb8fe2ead52eb541730dce9c6293cef87b015747b91c5
d9b9cc803a92476d1dbcb8fe2ead52eb541730dce9c6293cef87b015747b91c5

$ docker logs d9b9cc803a92476d1dbcb8fe2ead52eb541730dce9c6293cef87b015747b91c5
initializing the container
```

Note: this command does not start the container, it only reads its "STDOUT/STDERR" stream output.

#### `docker stop`

Emits a `SIGTERM` (terminate signal) to the container and give it 10 seconds until it can gracefully shutdown.

If it doesn't respond/end the process in 10 seconds, it will fallback to `docker kill` command, killing it right away.

```sh
$ docker create busybox ping google.com
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685

$ docker start 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685

$ docker logs 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
PING google.com (172.217.22.110): 56 data bytes
64 bytes from 172.217.22.110: seq=0 ttl=37 time=12.521 ms
64 bytes from 172.217.22.110: seq=1 ttl=37 time=14.064 ms
64 bytes from 172.217.22.110: seq=2 ttl=37 time=14.099 ms
64 bytes from 172.217.22.110: seq=3 ttl=37 time=12.590 ms

$ docker stop 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685 # Will hang the execution for 10 seconds...
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
```

#### `docker kill`

Emits a `SIGKILL` (kill signal) to the container, killing it right way, giving it no time for a graceful shutdown.

```sh
$ docker create busybox ping google.com
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685

$ docker start 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685

$ docker logs 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
PING google.com (172.217.22.110): 56 data bytes
64 bytes from 172.217.22.110: seq=0 ttl=37 time=12.521 ms
64 bytes from 172.217.22.110: seq=1 ttl=37 time=14.064 ms
64 bytes from 172.217.22.110: seq=2 ttl=37 time=14.099 ms
64 bytes from 172.217.22.110: seq=3 ttl=37 time=12.590 ms

$ docker kill 041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685 # Will kill it right away
041ad1d2bff9510ad157583b9657125d97ac2ae73f083f762dae164416031685
```

#### `docker exec`

Executes a given command inside the container and then exit it.

If you want to _interact_ with the container's bash, you must use the `-it` flag.

```sh
$ docker run redis

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
dfb7e776b3c5        redis               "docker-entrypoint.sâ€¦"   8 minutes ago       Up 8 minutes        6379/tcp            loving_hamilton

$ docker exec -it dfb7e776b3c5 redis-cli
127.0.0.1:6379> # Execute your redis command here.
```

Not providing the `-it` would execute the command and kick you off from the container's bash instantaneously.

```sh
$ docker run redis

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
dfb7e776b3c5        redis               "docker-entrypoint.sâ€¦"   8 minutes ago       Up 8 minutes        6379/tcp            loving_hamilton

$ docker exec -it dfb7e776b3c5 redis-cli
$ # Your terminal is waiting for new commands.
```

The flag `-it` is actually a combination of two flags, the `-i` and `-t`.

The `-i` flag attaches your bash to the `STDIN` (standard stream input) of the container, which means that everything that you type will be sent to `redis-cli` as an input (as if you were typing).

The `-t` flag attaches your bash to the `STOUT` (standard stream output) of the container, which means that everything responded by the `redis-cli` will be displayed and formatted for you in your bash.

If you want to avoid executing this command everytime you need to execute a bash command, you use `sh` (or `bash`, `zsh`...) as the `docker exec` command.

```sh
$ docker exec -it dfb7e776b3c5 sh
# ls
# cd
# ...
```

#### `docker commit`

As Docker `images` can create `containers`, the other way around is true as well with `docker commit`.

Here, we have the following `Dockerfile`:
```sh
# 1. Use an existing docker image as a base
FROM alpine

# 2. Download and install a dependency
RUN apk add --update redis
RUN apk add --update gcc

# 3. Tell the image what to do when its starts as a container
CMD [ "redis-server" ]
```

Which can be created by hand, for doing the following:

```sh
# terminal 1 - creates a container and leave it running
$ docker run -it alpine sh
$ apk add --update redis

# terminal 2 - grab the running container's id
$ docker ps
CONTAINER ID   IMAGE    COMMAND   CREATED          STATUS          PORTS   NAMES
9236f1b3f15f   alpine   "sh"      10 seconds ago   Up 10 seconds           jolly_kare

$ docker commit -c 'CMD [ "redis-server" ]' 9236f1b3f15f # -c overrides the "startup command"
sha256:ea69809ce4889243517658e24fe0854b34f29a68b93f083377cc57f6f26aaeb2 # only the very beginning of the id can be used "ea69809ce"

$ docker run ea69809ce
1:C 20 Jan 17:09:13.741 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
...
```